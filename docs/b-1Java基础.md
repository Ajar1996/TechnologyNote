## Java基础



### JDK和JRE

- JDK 

   Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

- JRE 

   Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。



### 基础类型

- byte/8
- char/16
- short/16
- int/32
- float/32
- long/64
- double/64
- boolean/~

boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。



### 访问修饰符 public,private,protected,以及不写（默认）时的区别？

|           | 当前类 | 同包 | 子类 | 其他类 |
| --------- | ------ | ---- | ---- | ------ |
| public    | √      | √    | √    | √      |
| protected | √      | √    | √    |        |
| default   | √      | √    |      |        |
| private   | √      |      |      |        |



### 为什么要有包装类？

1. 包装类多了一个Null值，增加了表达性；
2. 增加面向对象特性，（以致于能够）兼容集合的使用：
   比如集合能接收的类型为Object,基本类型是无法添加进去的。

基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。



### 重载和重写的区别

重载，实现的是编译时的多态性，发生在同一个类中，方法名相同，参数类型，个数，顺序不同，访问修饰符和返回值可以不同

重写，实现的是运行时的多态性，发生在运行期，子类可以重写父类的方法，方法名，返回值，参数列表必须相同，访问修饰符需要大于父类，抛出的异常范围小于父类。



### Java的四大特性

- 抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么
- 封装：把一个对象的属性私有化，当需要时可提供对外访问的方法。
- 继承：把一个已有的类作为基类创建新类的技术，新类可以复用父类的方法功能，也可以创建新的功能。使用继承我们可以很好的复用以前的代码
- 多态：就是程序中所定义的引用变量所指向的具体类型，和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定的。（接口和继承）



### String、StringBuffer、StringBuilder的区别

String底层是用char数组来保存字符串，用了final关键字。String中的对象是不可变的。每次改变都会在线程池中创建新的对象。1.9之后用byte数组

StirngBuffer和都StirngBuilder都继承自AbstractStringBuilder类，是可变的，提供了对字符串操作的API,StringBuffer是线程安全的，底层用了synchronized关键字修饰。



### final关键字

1. 对于一个final变量，如果是基本数据类型，其数值一旦初始化之后便不能改变；如果是引用类型，其初始化之后便不能再指向另一个对象

2. 当用final修饰一个类时，表明该类不能被继承，类中的所有方法都被隐式地指定为final方法
3. 修饰方法时，把方法锁定，防止继承类修改他的含义。类中的private都隐式指定为final



### 接口和抽象类的区别

- 抽象是类的抽象，是一种模板设计。指代的是“是不是”的关系，接口是对行为的抽象，是一种行为的规范，实则是有没有，具不具备的关系
- 抽象类可以存在普通成员类型，而接口中只能存在public abstract 类型
- 一个类只能继承一个抽象类，可以实现多个接口
- 接口的字段只能是static和final类型的



### 构造方法有那些特性

- 名字与类名相同
- 没有返回值，不用void
- 生成类对象时自动执行，无需调用



### ==和equals的区别

==比较的两个对象的内存地址是否相等，即判断两个对象是不是同一个对象（基本类型比较的是值，引用类型比较的是内存地址）

equals分两种情况

- 类没有覆盖equals方法：等同于==
- 覆盖了：我们一般用此方法来比较两个对象的内容是否相等。String就重写了这个方法



### HashCode和equals区别

Hashcode()获取对象的哈希码。用于确定该对象在哈希表中的位置，`hashcode` 只是用来缩小查找成本

如果两个对象相等，则HashCode一定相等，hashCode相等，对象不一定相等。覆盖equals方法时，hashcode也必须被覆盖。



### 为什么方法中只有值传递

⽅法得到的是所有参数值的⼀个拷⻉，也就是说，⽅法不能修改传递给它的任何参数变量的内容。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。



### 异常处理

在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类 有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。



#### Exception又分为受检异常和非受检异常（运行时异常）

- 受检异常：编译器在编译时必须用cry-catch或者throws处理，否则无法通过编译。

  > 常见受检异常：IO操作、ClassNotFoundException、SQLException、线程操作

- 运行时异常： RuntimeException及其子类都统称为非受检查异常

  > 常见运行时异常：NullPointExecrption、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）





### 成员变量和局部变量的区别

- 成员变量是属于类的，可以被访问控制修饰符和static修饰，局部变量属于方法，不能被访问控制修饰符和static修饰

- 成员变量在初始化的时候，如果不给指定值，则会自动以类型的默认值赋值。局部变量不会
- 如果成员变量没有用static修饰，则属于对象实例。对象存放于堆中。如果局部变量为基础类型则存放在栈内存，如果是引用类型，则存放的是指向堆内存对象的引用或者指向常量池的地址



### static 加载顺序

所有的静态初始化块都优先执行，其次才是非静态的初始化块和构造函数，它们的执行顺序是：

1. 父类的静态初始化块/静态成员,顺序是声明顺序
2. 子类的静态初始化块/静态成员,顺序是声明顺序
3. 父类的初始化块/成员变量(无论定义在构造方法前还是后)
4. 父类的构造函数
5. 子类的初始化块/成员变量(无论定义在构造方法前还是后)
6. 子类的构造函数



### 深拷贝和浅拷贝

- 浅拷贝：对基础数据类型，进行值传递，对引用数据类型，进行引用传递般的拷贝

- 深拷贝：对基础数据类型，进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。

  

### 动态代理和静态代理的区别：

静态代理：代理对象和被代理对象在代理之前就已经确定了，代理对象和被代理对象需要实现同一个接口，在代理时，由代理类的构造方法中创建出被代理类。被代理对象的class文件是在运行前就已经存在的。

动态代理：动态代理分为JDK动态代理和CGLIB动态代理，动态代理是在程序运行期间运用反射机制创建出被代理类。

- JDK动态代理：JDK动态代理产生的代理类和被代理类需要实现相同的接口。需要实现InvocationHandler()接口，实现里面的Invoke()方法。使用Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)创建出代理对象。
- CGlib动态代理：用于代理没有实现接口的对象。CGLIB动态代理产生的代理对象是被代理类的子类，将被代理对象类的Class文件加载进来，修改其字节码生成子类来处理。



### 反射

**Java反射机制**是在运行状态中，对于**任意**一个类，都能够知道这个类的**所有属性和方法**；对于**任意**一个对象，都能够调用它的**任意一个方法和属性**；这种动态获取的信息以及动态调用对象的方法的**功能**称为java语言的反射机制



### 获取Class对象的三种方式

- Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象
  多用于配置文件，将类名定义在配置文件中，读取文件，加载类
- 类名.class：通过类名的属性class获取
  多用于参数传递
- 对象.getClass()：getClass() 方法在Object类中定义着
  多用于对象的获取字节码的方式



### 泛型

泛型即是参数化类型，指定了要操作的类型。

它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。



#### 如何工作的 ? 什么是类型擦除 ?

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List\<String\>在运行时仅用一个List来表示。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。



#### 通配符

- ？：表示不确定的 java 类型

- T：表示具体的一个java类型

- K V (key value) 分别代表java键值中的Key Value
- E (element) 代表Element

