### RabbitMQ

#### 概念

##### Exchange

RabbitMQ的消息并不直接投放到消息队列中，而是会经过exchange的类型来分配到对应的消息队列



##### Exchange Type

常用类型有fanout、direct、topic、header、

1. fanout

   会把该Exchange的消息路由到所有绑定的Queue中，不做任何判断，一般用于广播信息

2. direct

   会把消息路由到bandingKey和RoutingKey完全匹配的Queue中

3. topic

   模糊匹配

   - RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;
   - BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；
   - BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)

4. headers

   不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配

##### Queue

Rabbit中的消息，只能储存在消息队列中

##### Broker 

可以看做一个RabbitMQ服务器

#### 常见问题

##### 如何保证消息的可靠传输（消息不丢失）？

##### 1.生产者传输过程中丢失数据

- 事务

  - 可以使用事务功能，在发送发消息前开启RabbitMq的事务，如果发送消息时发生异常，则可以回滚事务，然后重发。如果发送成功，则提交事务。但是事务机制是同步的。提交事务以后，会发生阻塞。

- Comfirm机制

  - 开启comfirm模式以后，每次写入的消息都会分配一个唯一的id。如果消息写入成功了，RabbitMq会回传一个ack消息，确认消息已经收到。否则，如果RabbitMQ没能处理这个消息，则会回调你的一个nack接口，告诉你消息接受失败了。

  

##### 2.消息队列自身消息丢失

- 持久化处理
  - 消息写入以后，把消息写入到磁盘。

##### 3.消费者还没处理就宕机了

- ack机制
  - 关闭RabbitMQ的自动ack机制，通过一个api来调用，当代码确保处理完的时候，再在程序里ack一次。

##### 消息失序问题

- RabbitMQ一个队列，多个消费者时会导致消息的失序问题。可以拆分多个queue，每个queue对应一个消费者。

##### 保证消息不被重复消费

1. 如果是写入数据库的，先根据主键查一下，如果是已经存在的就不插入，只更新
2. 如果是写入redis的，无所谓。天然幂等性。
3. 生产者每次写入消息加一个全局唯一ID，当消费时，根据id，去查一下，如果已经被消费过，则不处理。
4. 基于数据库的唯一键来保证重复数据不会重复插入多条。