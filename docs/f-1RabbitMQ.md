## RabbitMQ

### 特点

- 可靠性：RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。

- 灵活的路由：在消息进入队列之前，通过交换器来路由消息。
- 支持多种语言，多种协议



### 组件

#### Exchange

RabbitMQ的消息并不直接投放到消息队列中，而是会经过exchange的类型来分配到对应的消息队列



#### Exchange Type

常用类型有fanout、direct、topic、header



##### fanout

会把该Exchange的消息路由到所有绑定的Queue中，不做任何判断，一般用于广播信息



##### direct

会把消息路由到bandingKey和RoutingKey完全匹配的Queue中



##### topic

模糊匹配

- RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;
- BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；
- BindingKey 中可以存在两种特殊字符串“\*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)



##### headers

不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配



#### Queue

Rabbit中的消息，只能储存在消息队列中



#### Broker 

可以看做一个RabbitMQ服务器



### 死信队列

死信（Dead Letter），指无法被消费者正确地进行业务处理的消息，消费者消费时业务程序抛出了异常。队列中的信息由专门的消费者对死信进行处理，或者进行人工补偿。



#### 来源

当一个队列中的消息满足下述三种情况任一个时，改消息就会从原队列移至死信队列，若改队列没有绑定死信队列则消息被丢弃

1. 消息被否定确认使用 `channel.basicNack` 或 `channel.basicReject` ，并且此时`requeue` 属性被设置为`false`。
2. 消息在队列中的时间超过了设置的TTL（time to live）时间。
3. 消息数量超过了队列的容量限制。



信队列和普通的业务队列完全一样，只不过是业务上创建用来存储处理失败的消息的队列。所以其工作方式也和业务队列相同，死信仍然需要交换机的转发到达死信队列。



### 延迟队列

队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理。



#### 方式

- 对每条消息设置过期时间。
- 对队列设置过期时间。



#### 场景

##### 订单超时

当用户下订单后把订单推送到延迟队列，当到达时间未消费时，把消息放到死信队列，并由专门的消费者对该订单进行取消，若消费了，则由另一个专门的消费者对订单进行确认。



##### 会议开始通知

预订了一个会议，发送延迟消息到延迟队列中，等到达时间后会自动把消息放到死信队列中。然后由消费者对消息进行消费，发送通知



### 如何保证消息的可靠传输（消息不丢失）？

#### 1.生产者传输过程中丢失数据

- 事务

  - 可以使用事务功能，在发送发消息前开启RabbitMq的事务，如果发送消息时发生异常，则可以回滚事务，然后重发。如果发送成功，则提交事务。但是事务机制是同步的。提交事务以后，会发生阻塞。

- Comfirm机制

  - 开启comfirm模式以后，每次写入的消息都会分配一个唯一的id。如果消息写入成功了，RabbitMq会回传一个ack消息，确认消息已经收到。否则，如果RabbitMQ没能处理这个消息，则会回调你的一个nack接口，告诉你消息接受失败了。

  

##### 2.消息队列自身消息丢失

- 持久化处理
  - 消息写入以后，把消息写入到磁盘。



##### 3.消费者还没处理就宕机了

- ack机制
  - 关闭RabbitMQ的自动ack机制，通过一个api来调用，当代码确保处理完的时候，再在程序里ack一次
  - 当处理失败时，把消息转发到死信队列或者重新入队





### 消息失序问题

- RabbitMQ一个队列，多个消费者时会导致消息的失序问题。可以拆分多个queue，每个queue对应一个消费者。



### 如何保证消息不被重复消费

1. 如果是写入数据库的，先根据主键查一下，如果是已经存在的就不插入，只更新
2. 如果是写入redis的，无所谓。天然幂等性。
3. 生产者每次写入消息加一个全局唯一ID，当消费时，根据id，去查一下，如果已经被消费过，则不处理。
4. 基于数据库的唯一键来保证重复数据不会重复插入多条。