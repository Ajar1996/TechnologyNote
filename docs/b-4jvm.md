

## JVM



#### java内存区域

线程私有的

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的

- 堆
- 方法区（1.8后移除，变为元空间）
- 直接内存



##### 程序计数器

1. 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制
2. 在多线程情况下，程序计数器用于记录当前线程的执行位置，当线程被切换回来时就能知道上次执行到哪里了。

唯一一个不会抛出oom异常的内存区域

##### 虚拟机栈

由一个个栈帧组成，描述的是Java方法执行的内存模型。每次方法的调用都是通过栈传递的

Java内存可以粗糙地分为堆内存和栈内存，栈内存说的就是虚拟机栈或者栈中的局部变量表部分

##### 本地方法栈

为执行Native方法服务的



##### 堆

存放对象实例和数组

堆内存分为：新生代内存和老生代



##### 方法区

储存已被虚拟机加载的类信息，常量，静态变量等数据



#### 对象创建过程

1. 类加载检查：虚拟机遇到New指令时，会去检查能否在常量池定位到这个类的常量引用。并且检查这个类是否已经加载解析初始化过

2. 分配对象：类加载检查通过后，就会在堆中为对象分配内存。分配方式有：指针碰撞和空闲列表。由堆是否规整决定的。

   - 指针碰撞：内存规整时使用，把用过的内存整理到一边，没有用过的整理到另一边。然后中间有个分界指针，只要把该指针移动对象内存大小的位置即可
   - 空闲列表：不规整时使用，虚拟机维护一个列表。记录着哪些内存是可用的，分配时，只要将足够大的内存卡分配给对象。最后更新列表记录

   内存分配并发的解决：

   - CAS:每次不加锁，假设会分配成功，失败则重试，直到成功为止
   - TLAB:为每个线程预先在Eden分配内存，java给对象分配内存时，首先在TLAB分配，当对象大于TLAB的剩余内存或者已用尽时再用CAS分配

3. 初始化零值：将分配到的内存区域都初始化零值，保证了对象的实例字段在JAVA代码中不用赋初始值就能使用

4. 设置对象头：对对象进行必要的设置，如：对象的哈希码，对象的c分年年龄信息等

5. 执行init方法



#### 对象的访问方式

- 句柄
- 直接指针



#### 堆内存的分配策略

- 对象优先在eden区进行分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代



#### 如何判断对象已经死亡

- 引用计数法：给对象添加一个引用计数器，每当有一个地方引用到他时，计数器就加1。
- 可达性分析算法：通过⼀系列的称为 “GC Roots” 的对象作为起点，当一个对象到GC Roots没有任何引用链相连的时候，则证明该对象不可用



#### 判断常量是废弃常量

当没有任何String对象应用该字符串常量的话，就说明是废弃常量



#### 判断类是无用类

- 该类的所有实例都已经被回收
- 加载该类的classLoader已经被回收
- 该类对应的class对象没有在任何地方被引用，无法在任何地方通过反射获取到该类的方法。

#### 垃圾回收算法

##### 标记清除

标记出所有不需要回收的对象，然后回收没被标记的对象。效率问题，空间问题（产生大量不连续的碎片）

##### 复制算法

将内存分为一样大小的两块区域，每次使用其中一块，当这一块内存区域使用完后，就将还存活的对象复制到另一边，然后把使用的空间清理调

##### 标记整理

标记完后，让所有存活的对象向一端移动，直接清理掉端边界以外的内存

##### 分代收集算法

⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象 的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空 间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。

#### 引用

强引用：必不可少的生活用品：宁愿抛出错误也不回收他

软引用：当内存不足时，就会回收他。

弱引用：扫描到就会回收他。

虚引用：随时都可能会被回收

虚引⽤主要⽤来跟踪对象被垃圾回收的活动。
