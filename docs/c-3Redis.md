## Redis

#### 常见数据结构及使用场景

##### String

1. **介绍**：string 数据结构是简单的 key-value 类型

2. **常用命令：** `set,get,strlen,exists,decr,incr,setex` 等等。

3. **应用场景：** 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

   

##### list

1. **介绍**：Redis 的 list 的实现为一个 **双向链表**，即可以支持反向查找和遍历
2. **常用命令:** `rpush,lpop,lpush,rpop,lrange,llen` 等。
3. **应用场景:** 发布与订阅或者说消息队列、慢查询。



##### hash

1. **介绍**：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。另外，hash 是一个 string 类型的 field 和 value 的映射表，**特别适合用于存储对象**，可以用来存储用户信息，商品信息等等。
2. **常用命令:** `hset,hmset,hexists,hget,hgetall,hkeys,hvals` 等。
3. **应用场景:** 系统中对象数据的存储。



##### set

1. **介绍**：set 类似于 Java 中的 `HashSet` 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。可以基于 set 轻易实现交集、并集、差集的操作。
2. **常用命令:** `sadd,spop,smembers,sismember,scard,sinterstore,sunion` 等。
3. **应用场景:** 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景



##### sorted set

1. **介绍**：和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表

2. **常用命令:** `zadd,zcard,zscore,zrange,zrevrange,zrem` 等。

3. **应用场景:** 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。




#### 字符串的实现

Redis构建了一个叫做简单动态字符串，

```Java
struct sdshdr{
     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}
```



#### 如何判断是否为过期数据

Redis通过一个叫做过期字典（可以看做HashMap）来保存数据.过期字典的key指向Redis的某个键。值是一个Long long整数，保存的是过期时间



#### 过期策略

- 惰性删除：只在取出Key时对数据进行检查。对CPU好，但是会造成太多过期key没删除
- 定期删除：每隔一段时间抽取一批key执行删除过期key操作。并且Reids底层会通过限制删除操作执行的时长和频率来减少对CPU的影响

Redis采用定期删除+惰性删除

为了避免大量过期的Key堆积在内存，采用内存淘汰机制



#### 内存淘汰机制

1. Volatile-lru:从已设置过期时间的数据集，挑选最少使用的数据淘汰
2. Volatile-ttl:从已设置过期时间的数据集，挑选即将过期的数据淘汰
3. Volatile-random:从已设置过期时间的数据集，随机挑选数据淘汰
4. Allkey-lru:当内存不足以容纳写入新数据时，移除最少使用的Key
5. Allkeys-random:从数据集随机淘汰key
6. no-eviction:不足以容纳新数据时，报错
7. Volatile-lfu:从已设置过期时间的数据集，挑选最不经常使用的数据淘汰
8. Allkeys-lfu:当内存不足以容纳写入新数据时，移除最不经常使用的Key



#### 持久化操作

RDB:创建快照来存储在内存里面的数据在某个时间点上的副本

AOF:每执行一条更改Redis中数据的命令，都会将该命令写入硬盘中的AOF文件

4.0后：混合



#### 缓存穿透

大量请求的key根本不存在缓存中，直接请求到了数据库上。

解决：

1. 缓存无效Key
2. 布隆过滤器



#### 布隆过滤器

1. 使用布隆过滤器中的哈希函数对元素值计算，得到哈希值

2. 根据得到的哈希值，在位数组中把对应的下标置为1.

判断：

1. 对给定元素再次进行相同的哈希计算
2. 得到值后判断位数组中的每个元素是否都为1，如果都为1，则说明存在布隆过滤器中，不为1，说明该元素不在。

在布隆过滤器，不一定key存在缓存中，因为不同的字符串可能哈希出来的位置相同。（可以增加位数组大小或者调整哈希函数）



#### 缓存雪崩

缓存在同一时间里大量失效，后面的请求直接落到数据库上。

针对Reids服务不可用的解决：

1. 采用Redis集群，避免单机出现问题导致整个缓存服务都无法使用
2. 限流，避免同时处理大量请求

针对热点失效的解决：

1. 设置不同的失效时间
2. 缓存永不失效



#### 分布式锁

- 加锁，给Key设置一个值，并设置过期时间，避免死锁

  set lock_key random_value nx px 5000

- 解锁：用lua脚本保证解锁的原子性，判断当前锁的字符串是否于传入的值相等，是的话删除key



#### 哨兵

- 监控：检查主从服务器是否正常
- 提醒：当某个服务器异常时，通过api发送通知
- 自动故障迁移:当一个主服务器不能使用时，会将失效的主服务器的其中一个从服务器升为新的主服务器