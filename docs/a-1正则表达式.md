## 正则表达式



### 简介

正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。

可以利用[regexper.com](https://regexper.com)这个工具很好地可视化自己写的正则表达式:



### 字符

#### 单个字符

想在'apple'这个单词里找到‘a'这个字符，就直接用`/a/`这个正则就可以了。



但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**`\`**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：

我想匹配`*`这个符号，由于`*`这个符号本身是个特殊字符，所以我要利用转义元字符`\`来让它失去其本来的含义：

```R
/\*/
```



如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。



#### 多个字符



我们可以使用`[…]` 用来表示一组字符,用`-`连接区间范围

> 例如：
>
> `[amk]` 匹配 ‘a’，‘m’或’k’ 
>
> `[a-z]` 匹配所有的英文小写字母
>
> `[1-9]`匹配1-9的数字



除此之外还有匹配多字符的简便正则表达式

| 匹配区间                                      | 正则表达式 | 记忆方式            |
| --------------------------------------------- | ---------- | ------------------- |
| 除了换行符之外的任何字符                      | .          | 句号,除了句子结束符 |
| 单个数字, [0-9]                               | \d         | **d**igit           |
| 除了[0-9]                                     | \D         | **not** **d**igit   |
| 包括下划线在内的单个字符，[A-Za-z0-9_]        | \w         | **w**ord            |
| 非单字字符                                    | \W         | **not** **w**ord    |
| 匹配空白字符,包括空格、制表符、换页符和换行符 | \s         | **s**pace           |
| 匹配非空白字符                                | \S         | **not** **s**pace   |



### 循环与重复

要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。



#### 0|1

元字符`?`代表了匹配一个字符或0个字符。

> 匹配`color`和`colour`这两个单词，就需要同时保证`u`这个字符是否出现都能被匹配到
>
> `/colou?r/`



#### >= 0

元字符`*`用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。



#### >= 1

元字符`+`适用于要匹配同个字符出现1次或多次的情况。



#### 特定次数

在某些情况下，我们需要匹配特定的重复次数，元字符`{`和`}`用来给重复匹配设置精确的区间范围

> 如'a'我想匹配3次,那么我就使用`/a{3}/`这个正则，
>
> 或者说'a'我想匹配至少两次就是用`/a{2,}/`这个正则。



以下是完整的语法：

```
- {x}: x次

- {min, max}： 介于min次到max次之间

- {min, }: 至少min次

- {0, max}： 至多max次
```



| 匹配规则    | 元字符          | 联想方式                                                     |
| ----------- | --------------- | ------------------------------------------------------------ |
| 0次或1次    | ?               | 且**问**,此事**有**还**无**                                  |
| 0次或无数次 | *               | 宇宙洪荒,**辰宿**列张：宇宙伊始，从无到有，最后星宿布满星空  |
| 1次或无数次 | +               | **一加**, +1                                                 |
| 特定次数    | {x}, {min, max} | 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 |



### 位置边界

在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找



#### 单词边界

```
The cat scattered his food all over the room.
```

> 想找到`cat`这个单词，但是如果只是使用`/cat/`这个正则，就会同时匹配到`cat`和`scattered`这两处文本。
>
> 改写成`/\bcat\b/`这样就能匹配到`cat`这个单词了。

这时候我们就需要使用边界正则表达式`\b`，其中b是boundary的首字母。

在正则引擎里它其实匹配的是能构成单词的字符(\w)和不能构成单词的字符(\W)中间的那个位置。



#### 字符串边界

元字符`^`用来匹配字符串的开头。而元字符`$`用来匹配字符串的末尾。

> Match:	 		Mission: successful 
> Skip Last: 		Mission: unsuccessful 
> Skip Next: 		Mission: successful upon capture of target 
>
> `/^Mission: successful$/m`

| 边界和标志 | 正则表达式 | 记忆方式                              |
| ---------- | ---------- | ------------------------------------- |
| 单词边界   | \b         | **b**oundary                          |
| 非单词边界 | \B         | **not** **b**oundary                  |
| 字符串开头 | ^          | 小**头尖尖**那么大个                  |
| 字符串结尾 | $          | **终结**者，美国科幻电影，美元符$     |
| 多行模式   | m标志      | **m**ultiple of lines                 |
| 忽略大小写 | i标志      | **i**gnore case, case-**i**nsensitive |
| 全局模式   | g标志      | **g**lobal                            |



### 子表达式

从简单到复杂的正则表达式演变通常要采用**分组、回溯引用和逻辑处理**的思想。利用这三种规则，可以推演出无限复杂的正则表达式。



#### 分组

其中分组体现在：所有以`(`和`)`元字符所包含的正则表达式被分为一组，每一个分组都是一个**子表达式**，它也是构成高级正则表达式的基础。如果只是使用简单的`(regex)`匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。



#### 回溯引用

所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像`\1`,`\2`,....,其中`\1`表示引用的第一个子表达式，`\2`表示引用的第二个子表达式，以此类推。而`\0`则表示整个表达式。

> Hello what what is the first thing, and I am am scq000.
>
> 匹配两个连续相同的单词: 
>
> `\b(\w+)\s\1`



回溯引用在替换字符串中十分常用，语法上有些许区别，用`$1`,`$2`...来引用要被替换的字符串。

```
var str = 'abc abc 123';
str.replace(/(ab)c/g,'$1g');
// 得到结果 'abg abg 123'
```

如果我们不想子表达式被引用，可以使用**非捕获**正则`(?:regex)`这样就可以避免浪费内存。

```
var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2
```



##### 前向查找

前向查找(lookahead)是用来限制后缀的。

凡是以`(?=regex)`包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。

> `happy happily`
>
> 我想获得以`happ`开头的副词
>
> 那么就可以使用`happ(?=ily)`来匹配
>
> 如果我想过滤所有以`happ`开头的副词
>
> 那么也可以采用**负前向查找**的正则`happ(?!ily)`，就会匹配到`happy`单词的`happ`前缀。



##### 后反向查找

后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。

>  `apple`和`people`都包含`ple`这个后缀，那么如果我只想找到`apple`的`ple`，该怎么做呢？我们可以通过限制`app`这个前缀，就能唯一确定`ple`这个单词了。
>
> `/(?<=ap)ple/`



其中`(?<=regex)`的语法就是我们这里要介绍的后向查找。

`regex`指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向**后**查找。

另外一种限制匹配是利用`(?<!regex)` 语法，这里称为**负后向查找**。

与正前向查找不同的是，被指定的子表达式不能被匹配到。

于是，在上面的例子中，如果想要查找`apple`的`ple`也可以这么写成`/(?<!peo)ple`。



#### 逻辑处理

##### 与

默认的正则规则都是**与**的关系

##### 或

通常给子表达式进行归类使用。

比如，我同时匹配a,b两种情况就可以使用`(a|b)`这样的子表达式

##### 非

在字符匹配的时候，需要使用`^`这个元字符。

> 只有在`[`和`]`内部使用的`^`才表示非的关系

子表达式匹配的非关系，就要用到前向负查找子表达式`(?!regex)`或后向负查找子表达式`(?<!regex)`



### 总结

| 特殊字符   | 正则表达式 | 记忆方式                                     |
| ---------- | ---------- | -------------------------------------------- |
| 换行符     | \n         | **n**ew line                                 |
| 换页符     | \f         | **f**orm feed                                |
| 回车符     | \r         | **r**eturn                                   |
| 空白符     | \s         | **s**pace                                    |
| 制表符     | \t         | **t**ab                                      |
| 垂直制表符 | \v         | **v**ertical tab                             |
| 回退符     | [\b]       | **b**ackspace,之所以使用[]符号是避免和\b重复 |

| 匹配区间                                      | 正则表达式 | 记忆方式            |
| --------------------------------------------- | ---------- | ------------------- |
| 除了换行符之外的任何字符                      | .          | 句号,除了句子结束符 |
| 单个数字, [0-9]                               | \d         | **d**igit           |
| 除了[0-9]                                     | \D         | **not** **d**igit   |
| 包括下划线在内的单个字符，[A-Za-z0-9_]        | \w         | **w**ord            |
| 非单字字符                                    | \W         | **not** **w**ord    |
| 匹配空白字符,包括空格、制表符、换页符和换行符 | \s         | **s**pace           |
| 匹配非空白字符                                | \S         | **not** **s**pace   |

| 匹配规则    | 元字符          | 联想方式                                                     |
| ----------- | --------------- | ------------------------------------------------------------ |
| 0次或1次    | ?               | 且**问**,此事**有**还**无**                                  |
| 0次或无数次 | *               | 宇宙洪荒,**辰宿**列张：宇宙伊始，从无到有，最后星宿布满星空  |
| 1次或无数次 | +               | **一加**, +1                                                 |
| 特定次数    | {x}, {min, max} | 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 |

| 边界和标志 | 正则表达式 | 记忆方式                              |
| ---------- | ---------- | ------------------------------------- |
| 单词边界   | \b         | **b**oundary                          |
| 非单词边界 | \B         | **not** **b**oundary                  |
| 字符串开头 | ^          | 小**头尖尖**那么大个                  |
| 字符串结尾 | $          | **终结**者，美国科幻电影，美元符$     |
| 多行模式   | m标志      | **m**ultiple of lines                 |
| 忽略大小写 | i标志      | **i**gnore case, case-**i**nsensitive |
| 全局模式   | g标志      | **g**lobal                            |

| 回溯查找   | 正则                   | 记忆方式                                                     |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 引用       | \0,\1,\2 和 $0, $1, $2 | 转义+数字                                                    |
| 非捕获组   | (?:)                   | 引用表达式(()), 本身不被消费(?),引用(:)                      |
| 前向查找   | (?=)                   | 引用子表达式(())，本身不被消费(?), 正向的查找(=)             |
| 前向负查找 | (?!)                   | 引用子表达式(())，本身不被消费(?), 负向的查找(!)             |
| 后向查找   | (?<=)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=) |
| 后向负查找 | (?<!)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!) |

| 逻辑关系 | 正则元字符  |
| -------- | ----------- |
| 与       | 无          |
| 非       | [^regex]和! |
| 或       | \|          |

