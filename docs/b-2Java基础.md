## Java基础



##### 重载和重写的区别

重载发生在同一个类中，方法名相同，参数类型，个数，顺序不同，访问修饰符和返回值可以不同

重写发生在运行期，子类可以重写父类的方法，方法名，返回值，参数列表必须相同，访问修饰符需要大于父类，抛出的异常范围小于父类。



##### Java的三大特性

- 封装：把一个对象的属性私有化，当需要时可提供对外访问的方法。
- 继承：把一个已有的类作为基类创建新类的技术，新类可以复用父类的方法功能，也可以创建新的功能。使用继承我们可以很好的复用以前的代码
- 多态：就是程序中所定义的引用变量所指向的具体类型，和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行时才确定的。（接口和继承）

##### String、StringBuffer、StringBuilder的区别

String底层是用char数组来保存字符串，用了final关键字。String中的对象是不可变的。每次改变都会在线程池中创建新的对象。1.9之后用byte数组

StirngBuffer和都StirngBuilder都继承自AbstractStringBuilder类，是可变的，提供了对字符串操作的API,StringBuffer是线程安全的，底层用了synchronized关键字修饰。



##### final关键字

1. 对于一个final变量，如果是基本数据类型，其数值一旦初始化之后便不能改变；如果是引用类型，其初始化之后便不能再指向另一个对象

2. 当用final修饰一个类时，表明该类不能被继承，类中的所有方法都被隐式地指定为final方法
3. 修饰方法时，把方法锁定，防止继承类修改他的含义。类中的private都隐式指定为final



#####  接口和抽象类的区别

- 抽象是类的抽象，是一种模板设计。指代的是“是不是”的关系
- 接口是对行为的抽象，是一种行为的规范，实则是有没有，具不具备的关系
- 一个类只能继承一个抽象类，可以实现多个接口



##### 构造方法有那些特性

- 名字与类名相同
- 没有返回值，不用void
- 生成类对象时自动执行，无需调用



##### ==和equals的区别

==比较的两个对象的内存地址是否相等，即判断两个对象是不是同一个对象（基本类型比较的是值，引用类型比较的是内存地址）

equals分两种情况

- 类没有覆盖equals方法：等同于==
- 覆盖了：我们一般用此方法来比较两个对象的内容是否相等。String就重写了这个方法



##### HashCode和equals区别

Hashcode()获取对象的哈希码。用于确定该对象在哈希表中的位置。

如果两个对象相等，则HashCode一定相等，hashCode相等，对象不一定相等。覆盖equals方法时，hashcode也必须被覆盖。



##### 为什么方法中只有值传递

⽅法得到的是所有参数值的⼀个拷⻉，也就是说，⽅法不能修改传递给它的任何参数变量的内容。



##### 异常处理

在 Java 中，所有的异常都有⼀个共同的祖先 java.lang 包中的 Throwable 类。 Throwable 类 有两个重要的⼦类 Exception （异常）和 Error （错误）。 Exception 能被程序本身处理( trycatch )， Error 是⽆法处理的(只能尽量避免)。





##### 成员变量和局部变量的区别

- 成员变量是属于类的，可以被访问控制修饰符和static修饰，局部变量属于方法，不能被访问控制修饰符和static修饰

- 成员变量在初始化的时候，如果不给指定值，则会自动以类型的默认值赋值。局部变量不会
- 如果成员变量没有用static修饰，则属于对象实例。对象存放于堆中。如果局部变量为基础类型则存放在栈内存，如果是引用类型，则存放的是指向堆内存对象的引用或者指向常量池的地址



##### 深拷贝和浅拷贝

- 浅拷贝：对基础数据类型，进行值传递，对引用数据类型，进行引用传递般的拷贝

- 深拷贝：对基础数据类型，进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。

  

##### 动态代理和静态代理的区别：

静态代理：代理对象和被代理对象在代理之前就已经确定了，代理对象和被代理对象需要实现同一个接口，在代理时，由代理类的构造方法中创建出被代理类。被代理对象的class文件是在运行前就已经存在的。

动态代理：动态代理分为JDK动态代理和CGLIB动态代理，动态代理是在程序运行期间运用反射机制创建出被代理类。

- JDK动态代理：JDK动态代理产生的代理类和被代理类需要实现相同的接口。需要实现InvocationHandler()接口，实现里面的Invoke()方法。使用Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)创建出代理对象。
- CGlib动态代理：用于代理没有实现接口的对象。CGLIB动态代理产生的代理对象是被代理类的子类，将对象类的Class文件加载进来，修改其字节码生成子类来处理。



##### 反射

**Java反射机制**是在运行状态中，对于**任意**一个类，都能够知道这个类的**所有属性和方法**；对于**任意**一个对象，都能够调用它的**任意一个方法和属性**；这种动态获取的信息以及动态调用对象的方法的**功能**称为java语言的反射机制



###### 获取Class对象的三种方式

- Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象
  多用于配置文件，将类名定义在配置文件中，读取文件，加载类
- 类名.class：通过类名的属性class获取
  多用于参数传递
- 对象.getClass()：getClass() 方法在Object类中定义着
  多用于对象的获取字节码的方式
