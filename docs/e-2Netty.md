## Netty



### 简单介绍一下Netty

Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议的服务器和客户端

Netty是基于NIO的，底层封装了JDK的NIO，让我们使用起来更加灵活高效



#### 特点和优势

- 使用简单：底层封装了JDK的NIO，使用更加简单
- 功能强大：预置了多种编解码功能，支持多种主流协议
- 定制能力强：可以通过ChannelHandler对通信框架进行灵活的配置
- 性能高：与业界的其他RPC框架相比，Netty的综合性能更高



#### 为什么性能高

- 同步非阻塞的IO线程模型
- 内存零拷贝，减少了不必要的内存拷贝
- 支持多种高性能序列化协议
- 内存池设置：申请的内存可重用，主要指直接内存，底层用一个查找二叉树管理了内存的分配情况
- 串行化处理读写，避免了锁的开销



### 简单说下BIO/NIO/AIO

BIO：一个请求一个线程，客户端有效连接请求到达服务器时，服务器就需要开启一个线程被处理。请求一旦接收到一个连接请求，就可以建立通信套接字，在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，必须等当前客户端的操作执行完成，才可以接收其他客户端的连接请求。

伪异步IO：把连接请求放入线程池中，一对多，但线程是很宝贵的资源

NIO:一个请求一个线程，但客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才进行启动一个线程进行处理。



BIO和NIO的区别

- BIO是面向流的是单向的，而NIO是面向缓冲区的，是双向的。

- IO的各种流是阻塞的，当一个线程调用Read()或者Write()方法时，该线程就会被阻塞。但NIO可以进行非阻塞操作，比如说，单线程从通道读取数据到Buffer时，同时可以继续做别的事情。当数据读取到Buffer后，线程再继续处理数据。



AIO：一个有效请求一个线程，客户端的IO请求都是先由OS先完成了在通知服务端启动线程进行处理。



#### Netty线程模型

Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和worker线程池。Boss线程池的线程负责处理请求的accept事件，当接收到accept事件时，就把对应的socket封装到NIoSocketChannel中，并交给Work线程池。Work线程池负责请求的读写事件，由对应的handler处理。



####  Reactor线程模式

单线程模型：所有IO操作都由一个线程完成，即多路复用、事件的分发和处理都在同一个线程上完成。既要接收客户端的连接请求，向服务端发送连接，又要发送/读取请求或应答/响应消息。（接待员和服务员都是同一个人）



多线程模型：有一个NIO线程只负责监听服务端，接收客户端的tcp连接请求,NIO线程池负责处理网络IO操作。（一个接待员，N个服务员）



主从多线程模型： 服务端用于接收客户端连接的不再是单一的线程，而是一个NIO线程池，Acceptor线程池仅用于客户端的接入、认证、握手等操作。



#### TCP粘包/拆包问题

##### 为什么会发生粘包拆包的问题?

TCP是流的方式来处理数据的，当应用程序写入的字节大于套接字缓冲区时，就会发生拆包现象，而当应用程序写入的字节小于套接字缓冲区时，就会发生粘包事件。



##### Netty自带了解决方法：

- 消息定长:FixedLengthFrameDecoder类

- 包尾增加特殊分隔符：
  -  行分隔符类：LineBaseFrameDecoder类
  -  自定义分隔符类：DelimiterBaseFrameDecode类

- 将消息分为消息头和消息体的类



##### 框架的解决方法：

自定义协议：4B 魔数|4B消息类型|4B序列化器列席|4B消息长度 剩下的就是消息体



#### 说说Netty零拷贝

零拷贝是指避免用户态与内核态直接的来回拷贝数据的技术

- Netty的接收和发送Buffer采用Direct Buffers,采用堆外直接内存进行读写。不需要进行字节缓存区的二次拷贝
- Netty提供了组合Buffer对象，可以聚合几个Buffer对象，用户可以像通过操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小的Buffer合并成一个大的Buffer。
- Netty的文件传输采用了TransferTo方法，它可以直接将文件缓冲区的数据直接发送到目标的Channel,避免了传统通过循环While方式导致的内存拷贝问题



#### 简单说下Netty中的重要组件

- Channel:Netty网络操作的抽象类，包括基本的I/O操作，如bind、connect、read、write等
- EventLoop:主要配合Channel进行I/O操作，用来处理连接生命周期中发生的事情
- ChannelFuture:Netty框架中的所有I/O操作都是异步的，所以我们需要ChannelFuture()的addListner()方法注册一个监听事件，当操作执行成功或者失败时，监听就会自动返回结果。
- ChannelPipline：为ChannelHanddler链提供了容器，当channel创建时，就会被自动分配到它专属的ChannelPipeline,这个关联是永久性的。



#### Netty的责任链

Netty的pipline设计使用了责任链模式，底层使用了双向链表的数据结构，将链上的各个处理器串联起来



客户端每一个请求到来，netty都认为Pipline中的所有处理器都有机会能够处理到他，所以对于入栈的请求，全部都头结点开始往后传播，一直传播到尾节点



##### 责任机制

- 在Pipline的任意一个节点，只要我们不手动的往下传播，这个事件就会终止在当前节点
- 对于入栈数据，默认会传递到尾节点，进行回收。如果我们不进行下一步处理，就会终止在当前节点



#### Neety如何保持长链接的（心跳机制）

TCP协议提供了keepalive报文来探测服务端是否可用。



但有种情况，某台服务器因为某些原因负载超高，cpu100%,无法响应任何业务请求，但是使用TCP探针则仍能够确定连接状态，这就是典型的连接或者，但业务提供方 已死的情况。对客户端来说，我们希望能够断线后，重新连接其他服务器，而不是一直认为当前服务是可用状态，发送一些必然会失败的请求给服务端



Netty中提供了`IdleStateHandler`类专门用于处理心跳

```java
public IdleStateHandler(long readerIdleTime, long writerIdleTime,
                        long allIdleTime,TimeUnit unit){
}
```

第一个参数是隔多久检查一下读事件是否发生，如果 `channelRead()` 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 `userEventTrigger()` 方法；

第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 `write()` 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 `userEventTrigger()` 方法；

第三个参数是全能型参数，隔多久检查读写事件；

第四个参数表示当前的时间单位。

所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接

