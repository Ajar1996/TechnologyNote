## MySQL



### 数据库三范式

#### 第一范式

数据库表中的所有字段值都是不可分解的原子值

#### 第二范式

确保每一个列都和主键相关，而不能只和主键的某一部分相关（联合主键），也就是说一个表中只能存一种数据，不可以把多种数据存在数据库中

#### 第三范式

表中的每一列数据都和直接直接相关，而不能间接相关



### MyISAM和InnoDB的区别

MyISAM是5.5版本以前的默认引擎。后面版本引入了InnoDB

- 是否支持行级锁：MyISAM只支持表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁
- 是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询都具有原子性，其执行速度比InnoDB快,但不支持事务
- 是否支持外键:MyISAM不支持，InnoDB支持
- 是否支持MVCC：InnoDB支持，MVCC可以使用乐观锁和悲观锁来实现。MVCC仅在Read Committed和Repeatable Read两个隔离级别下工作



#### 索引

- MyISAM：B+Tree叶子节点的data域存放的是数据记录的地址。在检索时，首先按照B+Tree搜索算法，搜索索引，如果存在，取出data域的值，然后以data域的值为地址读取相应的数据记录。被称为："非聚簇索引"
- InnoDB:数据本身就是索引结构。B+Tree叶子节点的data域存放的是完整的数据记录。这个索引的key是数据表的主键，称为聚簇索引。其余的索引称为辅助索引，辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据



### 事务

事务：一组操作，要么都执行，要么都不执行



#### 四大特性

- 原子性：事务是最小的
- 一致性：事务执行前后，数据保持一致，多个事务对同一数据读取的结果都是相同的
- 隔离性：并发访问数据库时，一个事务不会被其他事务干扰。
- 持久性：一个事务提交后，对数据库的改变是永久的。



#### 事务实现原理（InnoDB）：

1. 使用redo log(重做日志)保证事务的持久性
2. 使用undo log(回滚日志)来保证事务的原子性
3. 通过锁机制、MVCC来保证事务的隔离性

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。



#### 带来的问题

- 脏读：
- 丢失更改：
- 不可重复读：
- 幻读：



#### 事务隔离级别

![image-20211216140707801](../images/c-2MySQL/image-20211216140707801.png)



InnoDB的隔离级别是Repeatable-Read



### MVCC

MVCC (Multi-Version Concurrency Control) 多版本并发控制。基本思想是为每次事务生成一个新版本的数据，在读数据时选择不同版本的数据即可对事务结果的完整性读取。



MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。

READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本

SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。











### 索引

#### 结构

##### B+树

- B+树是一个平衡的多叉树，层数为1~3层
- 同层级的节点间有指针相互链接，是有序的
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录



##### Hash索引

###### 优点

- 采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O 操作，理论上来说 Hash 比 B+ tree更快



###### 缺点

- 不支持范围查询
- 不支持索引完成排序
- 不支持联合索引的最左前缀匹配规则



#### 最左匹配原则

以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。



#### 索引为什么能提升效？

- 数据索引的存储是 有序的
- 在有序的情况下, 通过索引查询一个数据是无需遍历所有记录的



#### 为什么主键通常建议使用自增ID？

聚簇索引的数据存放的物理结构和索引的顺序是一致的，即只要索引是相邻的，那么对应的数据也一定是相邻的存放在磁盘上。如果ID不是自增的，那插入数据时就会不断地调整数据的物理地址。但如果自增的，那就只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。



#### 索引失效

![preview](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/996f7663e6bc4057a617fa922ffc6a44~tplv-k3u1fbpfcp-watermark.awebp)



### MySQL优化手段

1. 优化表结构，选择字段合适的数据类型，数据长度
2. SQL优化，使用索引
3. 表数据量很大时，可以进行分表
4. 数据库参数配置优化，如最大连接数、数据库占用的内存等
5. 采用集群，主从复制，读写分离
6. 增加缓存层
7. 升级服务器配置



#### SQL优化：

1. 避免全表扫描，考虑在 where 及 order by 涉及的列上建立索引。
2. 避免在 where 子句中使用!=或<>操作符、or、in/not in
3. 避免在where对字段进行Null值判断
4. 避免前后都模糊匹配like "%adb%"
5. 避免在 where 子句中对字段进行表达式操作
6. 避免在where子句中对字段进行函数操作
7. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算
8. .很多时候用 exists 代替 in 是一个好的选择
9. 尽量使用多表连接（join）查询（避免子查询）
10. 二者都能使用尽量使用where （与having比较）
    　　where 先过滤（数据就少了）再分组
11. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑
12. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
13. 较频繁地作为查询条件的字段，唯一性不太差的字段适合建立索引，更新不太频繁地字段适合创建索引，不会出现在where条件中的字段不该建立索引



### 分库分表

#### 好处

单机的存储能力、连接数有限，自身很容易成为系统的瓶颈。分库分表可以减少数据库的负担，缩短查询时间



#### 如何分库分表

分库分表就是要将大量数据分散到多个数据库中，核心理念是对数据进行切分

针对切分类型可以分为：

- 垂直切分
- 水平切分



##### 垂直切分

垂直切分可以分为垂直分库和垂直分表



###### 垂直分库

和微服务很像，将表按照业务分类进行划分，每个业务都有独立的数据库



![image-20220107160003283](../images/c-2MySQL/image-20220107160003283.png)

###### 垂直分表

基于数据表的列为依据切分。是一种大表拆小标的方式



###### 优点：

- 业务间解耦，不同业务的数据进行独立的维护、监控、扩展
- 在高并发场景下，一定程度上缓解了数据库的压力

###### 缺点：

- 提升了开发的复杂度，由于业务的隔离性，很多表无法直接访问，必须通过接口方式聚合数据，
- 分布式事务管理难度增加
- 数据库还是存在单表数据量过大的问题，并未根本上解决，需要配合水平切分



##### 水平切分

将大数据量的表，切分成多个表结构相同，而每个表只占原表的一部分数据。



###### 库内分表

库内分表虽然将表拆分，但子表都还是在同一个数据库实例中

![image-20220107160514269](../images/c-2MySQL/image-20220107160514269.png)



###### 分库分表

分库分表则是将切分出来的子表，分散到不同的数据库中，从而使得单个表的数据量变小，达到分布式的效果。





###### 优点：

- 解决高并发时单库数据量过大的问题，提升系统稳定性和负载能力
- 业务系统改造的工作量不是很大

###### 缺点：

- 跨分片的事务一致性难以保证
- 跨库的join关联查询性能较差
- 扩容的难度和维护量较大，（拆分成几千张子表想想都恐怖）



##### 数据该往哪个库的表存？

###### 根据取值范围

如根据时间区间和ID区间切分，如定义每个库只存10000条数据，那第一个库Id就是1~9999，第二个库就是10000~20000

**优点**：

- 单表数据量是可控的
- 能快速定位要查询的数据在哪个库

**缺点**：

- 由于连续分片可能存在数据热点，如果按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询



###### hash取模

hash取模mod（**对hash结果取余数 (hash() mod N)**）的切分方式比较常见

对数据库从0到N-1进行编号，对`User表`中`userId`字段进行取模，得到余数`i`，`i=0`存第一个库，`i=1`存第二个库，`i=2`存第三个库....以此类推。

**优点：**

- 数据分片相对比较均匀，不易出现某个库并发访问的问题

**缺点：**

- 但这种算法存在一些问题，当某一台机器宕机，本应该落在该数据库的请求就无法得到正确的处理，这时宕掉的实例会被踢出集群，此时算法变成hash(userId) mod N-1，用户信息可能就不再在同一个库中。



##### 存在的坑

###### 1、事务一致性问题

由于表分布在不同库中，不可避免会带来跨库事务问题。一般可使用"XA协议"和"两阶段提交"处理，但是这种方式性能较差，代码开发量也比较大。

通常做法是做到最终一致性的方案，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。



###### 2、分页、排序的坑

日常开发中分页、排序是必备功能，而多库进行查询时limit分页、order by排序，着实让人比较头疼。
分页需按照指定字段进行排序，如果排序字段恰好是分片字段时，通过分片规则就很容易定位到分片的位置；一旦排序字段非分片字段时，就需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户，过程比较复杂。



###### 3、全局唯一主键问题

由于分库分表后，表中的数据同时存在于多个数据库，而某个分区数据库的自增主键已经无法满足全局

唯一，所以此时一个能够生成全局唯一ID的系统是非常必要的。那么这个全局唯一ID就叫`分布式ID`





#### 清空数据库SQL 

SELECT CONCAT('truncate table ',TABLE_NAME,';') AS a FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'db_member' ;

